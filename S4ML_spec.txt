infos pour le parsing:
---------------------
en gros une ligne de S4ML c'est:
- soit une déclaration d'une variable (genre let x = 42) ==> [DEFINE Declaration]
- soit une déclaration d'une contrainte sur une variable préalablement déclarée (genre given contrainte sur x) ==> [DEFINE Constraint]
- soit une instruction = process un calcul, afficher un objet mathematique a l'ecran, etc ==> [DEFINE Instruction]

Declaration: [VarIdentifier] [Set] [MathObj]
-----------
c'est la chaine _ "\text{Let}\"
suivie d'un espace obligatoire ==> [DEFINE   __ = Mandatory_Whitespace]OK
suivie d'un espace optionnel _==> [DEFINE Whitespaces]OK
suivie d'un identifiant de variable ==> [DEFINE UndefinedVarIdentifier]OK
suivie d'un opérateur d'affectation (c'est a dire "=" ou "\\in") ==> [Define AffectationOperator]OK
amk

suivi d'un objet mathématique: ==> DEFINE [MathObj]
et du coup, ce qu'il y a a droite de l'opérateur d'affectation,
- soit c'est une variable ==> il faut que ca soit donc une DefinedVarIdentifier
- soit c'est un objet mathématique créé à la volée, c'est à dire une instruction qui retourne un objet mathématique (genre f.isEven() ou Function(t vers 2t, R dans R))

SI l'opérateur est un \in, alors il faudra que le MathObj soit un Set




SI l'affectation c'est un "=", alors:

alors le truc qu'on affecte, ca doit être un objet mathématique et c'est donc le contenu:
- soit une variable ==> du coup c'est un ExistingVarIdentifier ==> [DEFINE ExistingVarIdentifier]
  ==> puis ca check si

si c'est un \in, un objet mathématique d'ensemble (soit une variable préalablement définie qui est un ensemble, soit un ensemble déjà set genre R ou [0, 30[R, etc) ==> [DEFINE Set]

OU si c'est un =, suivie du truc affecté = objet mathématique (entier, autre variable, ensemble, fonction, etc ==> methodes constructeurs a definir) ==> [DEFINE MathObj]


MeasureUnit:
----------
= "\\text{" [A-Za-z0-9]+ "}"
==> pour definir des variables préalablement définies pour mesure des trucs genre des températures, distances, etc

UndefinedVarIdentifier:
----------------------
= VarIdentifier { checker s'il existe dans la memoire, si oui, throw, sinon on le return ==> permet d'être sûr qu'on ne re-définie pas une variable pré-existante}


DefinedVarIdentifier:
---------------------
= VarIdentifier { checker dans la memoire si ya une variable de ce nom là qui existe, si non, throw, si oui, le return directement ==> ca permet de throw si la variable existe pas}

+AffectationOperator
-------------------
= EqualOperator / InOperator ==> [DEFINE EqualOperator]OK et [DEFINE InOperator]OK

+EqualOperator
-------------
= "="

+InOperator
----------
"\\in"


+Mandatory_Whitespace: __
--------------------
= "\\ "

+Whitespaces: _
-----------
"\\ "*

+Identidiant de variable: VarIdentifier
-----------------------
c'est 1 symbole, forcément (sinon ca va foutre le bordel quand faudra gerer les produits avec les lettres qui se suivent)

donc un symbole, c'est à dire un caractère autorisé [a-zA-Z] ==> [DEFINE Letter]OK
OU
un signe, c'est à dire un truc genre \\varepsilon, \\lambda, etc = "\\" [a-zA-Z]+ ==> [DEFINE SpecialLetter]OK

suivi éventuellement par un type Indice ==> [DEFINE IdentifierIndice]OK

Indice de variable: IdentifierIndice
------------------
C'est un "_"
suivi par un Char ==> [DEFINE Char]OK
OU un specialChar ==> [DEFINE SpecialLetter]OK
OU d'un texte ==> [DEFINE Text]OK

puis EVENTUELLEMENT suivi par un autre indice IdentifierIndice?

+Letter:
------
= [A-Za-z]

+Text:
-----
= "\\text{" [A-Za-z0-9] "}"


+char:
-----
= [A-Za-z0-9]

+SpecialLetter:
-------------
= "\\" [A-Za-z]+ ==> return join()

contrainte Constraint:
---------------------

Instruction:
-----------


specifications du S4ML:
-----------------------

// let b1 = new S4ML_Bool(BoolValue.TRUE);
// let b2 = new S4ML_Bool(BoolValue.FALSE);
// let b3 = new S4ML_Bool(BoolValue.UNDETERMINED);

// console.log(b1.value);
// console.log(b2.value);
// console.log(b3.value);
. chaque contenu de ligne correspond à une commande
. une commande qui commence par Given est une definition de Statement, genre
  Given Statement
  ou
  Given x = 42

. Un statement correspond:
  - soit a une déclaration de variable, genre (Given x in R) ou (Given x = 42) ou (Given f = Function(x, R->R)) ou (Given eq_1 = Equation(x + 3 = 42))
  - soit à une declaration de contrainte sur une ou plusieurs variable préalablement déclarées, genre (x > 42) ou (x in R+) ou (f.isEven() = true) ou (x + 3 = 42)


. il y a des constantes prefefinies, genre True ou False qui sont des Bool(True) et Bool(False)

----
. les objects Bool sont des objets qui comprennent un attribut value qui peut valoir True, False ou Undetermined 
. Pour instanier un objet Bool, on fait Bool() ==> retourne un Bool de value Undetermined,
  ou Bool(AutreBool) qui retourne un Booleen qui a la meme valeur que le bool passé en parametre
----

----
. les objects fonction comprennent:
  - un ensemble de depart
  - un ensemble d'arrivée
  - le nom des variables d'entrée
  - l'expression de la sortie
----

----
. les objets equation, contiennent
  - la ou les variables a trouver en array
  - la ou les expressions sur lesquelles se baser en array
  - une methode solve qui retourne 
----

\int _{\Omega }^{ }\left(f\right)d_{\mu }

remarque sur la mesure:
une mesure deja c'est une mesure sur un ensemble E.
et en gros une mesure sur l'ensemble E, c'est le fait d'associer un nombre reel (ou + infini) à une partie de cet ensemble E

genre la temperature, c'est t'as l'ensemble des etats de températures possibles, et on va pouvoir associer un nombre reel a chaque partie des températures possibles

du coup un mesure, c'est une fonction m definie sur P(E) à valeurs dans R+
m: P(E) -> R+ U {+ infini}

et cette fonction a 2 propriétés / contraintes
pour A et B sous-ensembles de E disjoints,
m(A U B) = M(A) + M(B)
et
M(0) = 0

du coup pour le fait que m(A U B) = M(A) + M(B)
c'est un peu comme si on avait un magma
(P(E), U)
et un autre magma
(R, +)
et du coup, m est un morphisme de magma de (P(E), U) dans (R, +)
dans le cas où les 2 elements de P(E) sont disjoints

pour faire une application qui mesure le nombre d'elements dans un ensemble E, on a l'application
m: P(E) -> N, x -> card(x)

